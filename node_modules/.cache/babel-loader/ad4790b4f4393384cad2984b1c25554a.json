{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports', 'lodash/sortBy', 'lodash/reduce', 'lodash/head', 'lodash/last'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('lodash/sortBy'), require('lodash/reduce'), require('lodash/head'), require('lodash/last'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.sortBy, global.reduce, global.head, global.last);\n    global.sliderUtils = mod.exports;\n  }\n})(this, function (exports, _sortBy, _reduce, _head, _last) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.configureRange = configureRange;\n\n  var _sortBy2 = _interopRequireDefault(_sortBy);\n\n  var _reduce2 = _interopRequireDefault(_reduce);\n\n  var _head2 = _interopRequireDefault(_head);\n\n  var _last2 = _interopRequireDefault(_last);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n  /* EXAMPLE\n  \n  const range = [\n    { value: 0, step: 1},\n    { value: 20, step: 5 },\n    { value: 100 }\n  ]\n  \n  const Range = configureRange(range)\n  \n  Range.minStep // 0\n  Range.maxStep // 36\n  Range.getValueForStep(22) // 30\n  Range.getStepForValue(30) // 22\n  \n  */\n\n\n  function configureRange(range) {\n    // sort by ascending value.\n    var sorted = (0, _sortBy2.default)(range, function (b) {\n      return b.value;\n    } // calculates stepsSoFar on each value breakpoint\n    // for easier value/step calulations later.\n    );\n    var breakpoints = (0, _reduce2.default)(sorted, function (result, curr, key) {\n      // to calculate stepsSoFar we must get the\n      // range of values from the previous breakpoint\n      // to our current breakpoint.\n      var prev = sorted[key - 1];\n\n      if (prev) {\n        // calculate number of steps to reach the\n        // breakpoint value.\n        curr.stepsSoFar = (curr.value - prev.value) / prev.step + prev.stepsSoFar;\n      } else {\n        // the first breakpoint represents min value\n        // so stepsSoFar will always be 0.\n        curr.stepsSoFar = 0;\n      } // final breakpoint represents max value\n      // so user isn't forced to set a step\n      // even though we need it here.\n\n\n      if (_typeof(curr.step) === (typeof undefined === 'undefined' ? 'undefined' : _typeof(undefined))) {\n        curr.step = 1;\n      }\n\n      result.push(curr);\n      return result;\n    }, [] // min and max for easier calculations later\n    );\n    var minStep = (0, _head2.default)(breakpoints).stepsSoFar;\n    var maxStep = (0, _last2.default)(breakpoints).stepsSoFar;\n    var minValue = (0, _head2.default)(breakpoints).value;\n    var maxValue = (0, _last2.default)(breakpoints).value; // return value within min and max value range\n\n    var ensureValue = function ensureValue(value) {\n      if (value > maxValue) {\n        return maxValue;\n      } else if (value < minValue) {\n        return minValue;\n      } else {\n        return value;\n      }\n    }; // calculates value for current steps\n\n\n    var getValueForStep = function getValueForStep(step) {\n      // find the nearest breakpoint behind current step\n      var nearest = (0, _reduce2.default)(breakpoints, function (prev, curr) {\n        return curr.stepsSoFar < step && curr.stepsSoFar > prev.stepsSoFar ? curr : prev;\n      }, (0, _head2.default)(breakpoints) // determine value past nearest breakpoint value\n      );\n      var additionalValue = (step - nearest.stepsSoFar) * nearest.step;\n      return nearest.value + additionalValue;\n    }; // calculates number of steps for current value\n\n\n    var getStepForValue = function getStepForValue(value) {\n      // find the nearest breakpoint behind current value\n      var nearest = (0, _reduce2.default)(breakpoints, function (prev, curr) {\n        return curr.value < value && curr.value > prev.value ? curr : prev;\n      }, (0, _head2.default)(breakpoints) // determine number of steps past nearest breakpoint steps so far\n      );\n      var additionalSteps = (value - nearest.value) / nearest.step;\n      return nearest.stepsSoFar + additionalSteps;\n    };\n\n    return {\n      minStep: minStep,\n      maxStep: maxStep,\n      minValue: minValue,\n      maxValue: maxValue,\n      ensureValue: ensureValue,\n      getValueForStep: getValueForStep,\n      getStepForValue: getStepForValue\n    };\n  }\n});","map":{"version":3,"sources":["/Users/berkerbanar/Desktop/A_SYSTEMATIC_ANALYSIS/Eval_App/node_modules/react-step-range-slider/dist/slider-utils.js"],"names":["global","factory","define","amd","exports","require","mod","sortBy","reduce","head","last","sliderUtils","_sortBy","_reduce","_head","_last","Object","defineProperty","value","configureRange","_sortBy2","_interopRequireDefault","_reduce2","_head2","_last2","obj","__esModule","default","_typeof","Symbol","iterator","constructor","prototype","range","sorted","b","breakpoints","result","curr","key","prev","stepsSoFar","step","undefined","push","minStep","maxStep","minValue","maxValue","ensureValue","getValueForStep","nearest","additionalValue","getStepForValue","additionalSteps"],"mappings":"AAAA,CAAC,UAAUA,MAAV,EAAkBC,OAAlB,EAA2B;AAC1B,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACC,GAA3C,EAAgD;AAC9CD,IAAAA,MAAM,CAAC,CAAC,SAAD,EAAY,eAAZ,EAA6B,eAA7B,EAA8C,aAA9C,EAA6D,aAA7D,CAAD,EAA8ED,OAA9E,CAAN;AACD,GAFD,MAEO,IAAI,OAAOG,OAAP,KAAmB,WAAvB,EAAoC;AACzCH,IAAAA,OAAO,CAACG,OAAD,EAAUC,OAAO,CAAC,eAAD,CAAjB,EAAoCA,OAAO,CAAC,eAAD,CAA3C,EAA8DA,OAAO,CAAC,aAAD,CAArE,EAAsFA,OAAO,CAAC,aAAD,CAA7F,CAAP;AACD,GAFM,MAEA;AACL,QAAIC,GAAG,GAAG;AACRF,MAAAA,OAAO,EAAE;AADD,KAAV;AAGAH,IAAAA,OAAO,CAACK,GAAG,CAACF,OAAL,EAAcJ,MAAM,CAACO,MAArB,EAA6BP,MAAM,CAACQ,MAApC,EAA4CR,MAAM,CAACS,IAAnD,EAAyDT,MAAM,CAACU,IAAhE,CAAP;AACAV,IAAAA,MAAM,CAACW,WAAP,GAAqBL,GAAG,CAACF,OAAzB;AACD;AACF,CAZD,EAYG,IAZH,EAYS,UAAUA,OAAV,EAAmBQ,OAAnB,EAA4BC,OAA5B,EAAqCC,KAArC,EAA4CC,KAA5C,EAAmD;AAC1D;;AAEAC,EAAAA,MAAM,CAACC,cAAP,CAAsBb,OAAtB,EAA+B,YAA/B,EAA6C;AAC3Cc,IAAAA,KAAK,EAAE;AADoC,GAA7C;AAGAd,EAAAA,OAAO,CAACe,cAAR,GAAyBA,cAAzB;;AAEA,MAAIC,QAAQ,GAAGC,sBAAsB,CAACT,OAAD,CAArC;;AAEA,MAAIU,QAAQ,GAAGD,sBAAsB,CAACR,OAAD,CAArC;;AAEA,MAAIU,MAAM,GAAGF,sBAAsB,CAACP,KAAD,CAAnC;;AAEA,MAAIU,MAAM,GAAGH,sBAAsB,CAACN,KAAD,CAAnC;;AAEA,WAASM,sBAAT,CAAgCI,GAAhC,EAAqC;AACnC,WAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AACnCE,MAAAA,OAAO,EAAEF;AAD0B,KAArC;AAGD;;AAED,MAAIG,OAAO,GAAG,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA3D,GAAsE,UAAUL,GAAV,EAAe;AACjG,WAAO,OAAOA,GAAd;AACD,GAFa,GAEV,UAAUA,GAAV,EAAe;AACjB,WAAOA,GAAG,IAAI,OAAOI,MAAP,KAAkB,UAAzB,IAAuCJ,GAAG,CAACM,WAAJ,KAAoBF,MAA3D,IAAqEJ,GAAG,KAAKI,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOP,GAAzH;AACD,GAJD;AAMA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEE,WAASN,cAAT,CAAwBc,KAAxB,EAA+B;AAC7B;AACA,QAAIC,MAAM,GAAG,CAAC,GAAGd,QAAQ,CAACO,OAAb,EAAsBM,KAAtB,EAA6B,UAAUE,CAAV,EAAa;AACrD,aAAOA,CAAC,CAACjB,KAAT;AACD,KAFY,CAGb;AACA;AAJa,KAAb;AAKE,QAAIkB,WAAW,GAAG,CAAC,GAAGd,QAAQ,CAACK,OAAb,EAAsBO,MAAtB,EAA8B,UAAUG,MAAV,EAAkBC,IAAlB,EAAwBC,GAAxB,EAA6B;AAC7E;AACA;AACA;AACA,UAAIC,IAAI,GAAGN,MAAM,CAACK,GAAG,GAAG,CAAP,CAAjB;;AACA,UAAIC,IAAJ,EAAU;AACR;AACA;AACAF,QAAAA,IAAI,CAACG,UAAL,GAAkB,CAACH,IAAI,CAACpB,KAAL,GAAasB,IAAI,CAACtB,KAAnB,IAA4BsB,IAAI,CAACE,IAAjC,GAAwCF,IAAI,CAACC,UAA/D;AACD,OAJD,MAIO;AACL;AACA;AACAH,QAAAA,IAAI,CAACG,UAAL,GAAkB,CAAlB;AACD,OAb4E,CAc7E;AACA;AACA;;;AACA,UAAIb,OAAO,CAACU,IAAI,CAACI,IAAN,CAAP,MAAwB,OAAOC,SAAP,KAAqB,WAArB,GAAmC,WAAnC,GAAiDf,OAAO,CAACe,SAAD,CAAhF,CAAJ,EAAkG;AAChGL,QAAAA,IAAI,CAACI,IAAL,GAAY,CAAZ;AACD;;AACDL,MAAAA,MAAM,CAACO,IAAP,CAAYN,IAAZ;AACA,aAAOD,MAAP;AACD,KAtBmB,EAsBjB,EAtBiB,CAwBpB;AAxBoB,KAAlB;AAyBA,QAAIQ,OAAO,GAAG,CAAC,GAAGtB,MAAM,CAACI,OAAX,EAAoBS,WAApB,EAAiCK,UAA/C;AACF,QAAIK,OAAO,GAAG,CAAC,GAAGtB,MAAM,CAACG,OAAX,EAAoBS,WAApB,EAAiCK,UAA/C;AACA,QAAIM,QAAQ,GAAG,CAAC,GAAGxB,MAAM,CAACI,OAAX,EAAoBS,WAApB,EAAiClB,KAAhD;AACA,QAAI8B,QAAQ,GAAG,CAAC,GAAGxB,MAAM,CAACG,OAAX,EAAoBS,WAApB,EAAiClB,KAAhD,CAnC6B,CAqC7B;;AACA,QAAI+B,WAAW,GAAG,SAASA,WAAT,CAAqB/B,KAArB,EAA4B;AAC5C,UAAIA,KAAK,GAAG8B,QAAZ,EAAsB;AACpB,eAAOA,QAAP;AACD,OAFD,MAEO,IAAI9B,KAAK,GAAG6B,QAAZ,EAAsB;AAC3B,eAAOA,QAAP;AACD,OAFM,MAEA;AACL,eAAO7B,KAAP;AACD;AACF,KARD,CAtC6B,CAgD7B;;;AACA,QAAIgC,eAAe,GAAG,SAASA,eAAT,CAAyBR,IAAzB,EAA+B;AACnD;AACA,UAAIS,OAAO,GAAG,CAAC,GAAG7B,QAAQ,CAACK,OAAb,EAAsBS,WAAtB,EAAmC,UAAUI,IAAV,EAAgBF,IAAhB,EAAsB;AACrE,eAAOA,IAAI,CAACG,UAAL,GAAkBC,IAAlB,IAA0BJ,IAAI,CAACG,UAAL,GAAkBD,IAAI,CAACC,UAAjD,GAA8DH,IAA9D,GAAqEE,IAA5E;AACD,OAFa,EAEX,CAAC,GAAGjB,MAAM,CAACI,OAAX,EAAoBS,WAApB,CAFW,CAGd;AAHc,OAAd;AAIE,UAAIgB,eAAe,GAAG,CAACV,IAAI,GAAGS,OAAO,CAACV,UAAhB,IAA8BU,OAAO,CAACT,IAA5D;AACF,aAAOS,OAAO,CAACjC,KAAR,GAAgBkC,eAAvB;AACD,KARD,CAjD6B,CA2D7B;;;AACA,QAAIC,eAAe,GAAG,SAASA,eAAT,CAAyBnC,KAAzB,EAAgC;AACpD;AACA,UAAIiC,OAAO,GAAG,CAAC,GAAG7B,QAAQ,CAACK,OAAb,EAAsBS,WAAtB,EAAmC,UAAUI,IAAV,EAAgBF,IAAhB,EAAsB;AACrE,eAAOA,IAAI,CAACpB,KAAL,GAAaA,KAAb,IAAsBoB,IAAI,CAACpB,KAAL,GAAasB,IAAI,CAACtB,KAAxC,GAAgDoB,IAAhD,GAAuDE,IAA9D;AACD,OAFa,EAEX,CAAC,GAAGjB,MAAM,CAACI,OAAX,EAAoBS,WAApB,CAFW,CAGd;AAHc,OAAd;AAIE,UAAIkB,eAAe,GAAG,CAACpC,KAAK,GAAGiC,OAAO,CAACjC,KAAjB,IAA0BiC,OAAO,CAACT,IAAxD;AACF,aAAOS,OAAO,CAACV,UAAR,GAAqBa,eAA5B;AACD,KARD;;AAUA,WAAO;AACLT,MAAAA,OAAO,EAAEA,OADJ;AAELC,MAAAA,OAAO,EAAEA,OAFJ;AAGLC,MAAAA,QAAQ,EAAEA,QAHL;AAILC,MAAAA,QAAQ,EAAEA,QAJL;AAKLC,MAAAA,WAAW,EAAEA,WALR;AAMLC,MAAAA,eAAe,EAAEA,eANZ;AAOLG,MAAAA,eAAe,EAAEA;AAPZ,KAAP;AASD;AACF,CAzID","sourcesContent":["(function (global, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    define(['exports', 'lodash/sortBy', 'lodash/reduce', 'lodash/head', 'lodash/last'], factory);\n  } else if (typeof exports !== \"undefined\") {\n    factory(exports, require('lodash/sortBy'), require('lodash/reduce'), require('lodash/head'), require('lodash/last'));\n  } else {\n    var mod = {\n      exports: {}\n    };\n    factory(mod.exports, global.sortBy, global.reduce, global.head, global.last);\n    global.sliderUtils = mod.exports;\n  }\n})(this, function (exports, _sortBy, _reduce, _head, _last) {\n  'use strict';\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.configureRange = configureRange;\n\n  var _sortBy2 = _interopRequireDefault(_sortBy);\n\n  var _reduce2 = _interopRequireDefault(_reduce);\n\n  var _head2 = _interopRequireDefault(_head);\n\n  var _last2 = _interopRequireDefault(_last);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  /* EXAMPLE\n  \n  const range = [\n    { value: 0, step: 1},\n    { value: 20, step: 5 },\n    { value: 100 }\n  ]\n  \n  const Range = configureRange(range)\n  \n  Range.minStep // 0\n  Range.maxStep // 36\n  Range.getValueForStep(22) // 30\n  Range.getStepForValue(30) // 22\n  \n  */\n\n  function configureRange(range) {\n    // sort by ascending value.\n    var sorted = (0, _sortBy2.default)(range, function (b) {\n      return b.value;\n    }\n    // calculates stepsSoFar on each value breakpoint\n    // for easier value/step calulations later.\n    );var breakpoints = (0, _reduce2.default)(sorted, function (result, curr, key) {\n      // to calculate stepsSoFar we must get the\n      // range of values from the previous breakpoint\n      // to our current breakpoint.\n      var prev = sorted[key - 1];\n      if (prev) {\n        // calculate number of steps to reach the\n        // breakpoint value.\n        curr.stepsSoFar = (curr.value - prev.value) / prev.step + prev.stepsSoFar;\n      } else {\n        // the first breakpoint represents min value\n        // so stepsSoFar will always be 0.\n        curr.stepsSoFar = 0;\n      }\n      // final breakpoint represents max value\n      // so user isn't forced to set a step\n      // even though we need it here.\n      if (_typeof(curr.step) === (typeof undefined === 'undefined' ? 'undefined' : _typeof(undefined))) {\n        curr.step = 1;\n      }\n      result.push(curr);\n      return result;\n    }, []\n\n    // min and max for easier calculations later\n    );var minStep = (0, _head2.default)(breakpoints).stepsSoFar;\n    var maxStep = (0, _last2.default)(breakpoints).stepsSoFar;\n    var minValue = (0, _head2.default)(breakpoints).value;\n    var maxValue = (0, _last2.default)(breakpoints).value;\n\n    // return value within min and max value range\n    var ensureValue = function ensureValue(value) {\n      if (value > maxValue) {\n        return maxValue;\n      } else if (value < minValue) {\n        return minValue;\n      } else {\n        return value;\n      }\n    };\n\n    // calculates value for current steps\n    var getValueForStep = function getValueForStep(step) {\n      // find the nearest breakpoint behind current step\n      var nearest = (0, _reduce2.default)(breakpoints, function (prev, curr) {\n        return curr.stepsSoFar < step && curr.stepsSoFar > prev.stepsSoFar ? curr : prev;\n      }, (0, _head2.default)(breakpoints)\n      // determine value past nearest breakpoint value\n      );var additionalValue = (step - nearest.stepsSoFar) * nearest.step;\n      return nearest.value + additionalValue;\n    };\n\n    // calculates number of steps for current value\n    var getStepForValue = function getStepForValue(value) {\n      // find the nearest breakpoint behind current value\n      var nearest = (0, _reduce2.default)(breakpoints, function (prev, curr) {\n        return curr.value < value && curr.value > prev.value ? curr : prev;\n      }, (0, _head2.default)(breakpoints)\n      // determine number of steps past nearest breakpoint steps so far\n      );var additionalSteps = (value - nearest.value) / nearest.step;\n      return nearest.stepsSoFar + additionalSteps;\n    };\n\n    return {\n      minStep: minStep,\n      maxStep: maxStep,\n      minValue: minValue,\n      maxValue: maxValue,\n      ensureValue: ensureValue,\n      getValueForStep: getValueForStep,\n      getStepForValue: getStepForValue\n    };\n  }\n});"]},"metadata":{},"sourceType":"script"}